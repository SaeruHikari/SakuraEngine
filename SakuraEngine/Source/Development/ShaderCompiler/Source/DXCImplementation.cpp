#ifdef SAKURA_TARGET_PLATFORM_WIN
#include "ShaderCompiler/ShaderCompiler.h"
#include "dxc/dxcapi.h"
#include <atlbase.h>
#include <locale> 
#include <codecvt> 
namespace utf_converter
{
    using converter = std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t>;

    std::string utf16_to_utf8(std::wstring utf16_string)
    {
        return converter{}.to_bytes(utf16_string);
    }

    std::wstring utf8_to_utf16(std::string utf8_string)
    {
        return converter{}.from_bytes(utf8_string);
    }
}

using namespace sakura::development;

ShaderCompilerAPI sakura::vector<std::byte> sakura::development::compile_hlsl(
    const sakura::string& code, const ShaderCompilerVariables& vars)
{
    using namespace sakura::graphics;
    // 
    // Create compiler and utils.
    //
    CComPtr<IDxcUtils> pUtils;
    CComPtr<IDxcCompiler3> pCompiler;
    DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
    DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

    //
    // Create default include handler. (You can create your own...)
    //
    CComPtr<IDxcIncludeHandler> pIncludeHandler;
    pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);
    std::wstring target = L"vs_6_5";

    switch (vars.freq)
    {
    case EShaderFrequency::VertexShader:
        target = L"vs_6_5"; break;
    case EShaderFrequency::PixelShader:
        target = L"ps_6_5"; break;
    case EShaderFrequency::ComputeShader:
        target = L"cs_6_5"; break;
    default:
        break;
    }

    //
    // COMMAND LINE: dxc myshader.hlsl -E main -T ps_6_0 -Zi -D MYDEFINE=1 -Fo myshader.bin -Fd myshader.pdb -Qstrip_reflect
    //
    auto name_u16 = utf_converter::utf8_to_utf16(vars.name);
    auto entry_u16 = utf_converter::utf8_to_utf16(vars.entry);
    std::vector<LPCWSTR> pszArgs =
    {
        // Optional shader source file name for error reporting and for PIX shader source view.  
        name_u16.c_str(),
        // Entry point.
        L"-E", entry_u16.c_str(),
        L"-T", target.c_str(),            // Target.
        L"-Zi",                      // Enable debug information.
        L"-D", L"MYDEFINE=1",        // A single define.
        //L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
        //L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
        L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
        L"-O3",
    };
    if (vars.target_language == EShaderLanguage::Spirv)
    {
        pszArgs.emplace_back(L"-spirv");
    }
    else if (vars.target_language == EShaderLanguage::DXIL)
    {
        // Do Nothing.
    }
    else if (vars.target_language == EShaderLanguage::DXBC)
    {
        // Not Supported.
        assert(0 && "DXBC is not supported!");
    }
    //
    // Open source file.  
    //
    DxcBuffer Source;
    Source.Ptr = code.data();
    Source.Size = code.size();
    // Assume BOM says UTF8 or UTF16 or this is ANSI text.
    Source.Encoding = DXC_CP_ACP; 

    //
    // Compile it with specified arguments.
    //
    CComPtr<IDxcResult> pResults;
    pCompiler->Compile(
        &Source,                // Source buffer.
        pszArgs.data(),                // Array of pointers to arguments.
        pszArgs.size(),      // Number of arguments.
        pIncludeHandler,        // User-provided interface to handle #include directives (optional).
        IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
    );

    //
    // Print errors if present.
    //
    CComPtr<IDxcBlobUtf8> pErrors = nullptr;
    pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
    // Note that d3dcompiler would return null if no errors or warnings are present.  
    // IDxcCompiler3::Compile will always return an error buffer, but its length will be zero if there are no warnings or errors.
    if (pErrors != nullptr && pErrors->GetStringLength() != 0)
        wprintf(L"Warnings and Errors:\n%S\n", pErrors->GetStringPointer());

    //
    // Quit if the compilation failed.
    //
    HRESULT hrStatus;
    pResults->GetStatus(&hrStatus);
    if (FAILED(hrStatus))
    {
        wprintf(L"Compilation Failed\n");
        return sakura::vector<std::byte>();
    }

    //
    // Save shader binary.
    //
    CComPtr<IDxcBlob> pShader = nullptr;
    CComPtr<IDxcBlobUtf16> pShaderName = nullptr;
    pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&pShader), &pShaderName);
    if (pShader != nullptr)
    {
        auto ptr = static_cast<std::byte*>(pShader->GetBufferPointer());
        sakura::vector<std::byte> result(ptr, ptr + pShader->GetBufferSize());
        return result;
    }

    return sakura::vector<std::byte>();
}



#endif